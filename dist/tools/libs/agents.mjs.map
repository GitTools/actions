{"version":3,"file":"agents.mjs","sources":["../../../src/agents/common/lookPath.ts","../../../src/agents/common/build-agent.ts"],"sourcesContent":["import * as fs from 'node:fs/promises'\nimport * as path from 'node:path'\nimport * as process from 'node:process'\n\n/**\n * Sometimes, people want to look for local executable files\n * which are specified with either relative or absolute file path.\n * @private\n * @param cmd\n * @return {string} An absolute path of given command, or undefined.\n */\nconst isFilePath = (cmd: string): string | undefined => {\n    return cmd.includes(path.sep) ? path.resolve(cmd) : undefined\n}\n\n/**\n * Just promisifies \"fs.access\"\n * @private\n * @param {string} filePath An absolute file path with an applicable extension appended.\n * @return {Promise<string>} Resolves absolute path or empty string.\n */\nconst access = async (filePath: string): Promise<string | undefined> => {\n    try {\n        await fs.access(filePath)\n        return filePath\n    } catch (_error) {\n        return undefined\n    }\n}\n\n/**\n * Resolves if the given file is executable or not, regarding \"PATHEXT\" to be applied.\n * @private\n * @param {string} absPath A file path to be checked.\n * @param {LookPathOption} options Options for lookPath.\n * @return {Promise<string>} Resolves the absolute file path just checked, or undefined.\n */\nconst isExecutable = async (absPath: string, options: LookPathOption = {}): Promise<string | undefined> => {\n    const envVars = options.env || process.env\n    const extension = (envVars.PATHEXT || '').split(path.delimiter).concat('')\n    const bins = await Promise.all(extension.map(async ext => access(absPath + ext.toLowerCase())))\n    return bins.find(bin => !!bin)\n}\n\n/**\n * Returns a list of directories on which the target command should be looked for.\n * @private\n * @param {string[]} options.include Will be added to \"PATH\" env.\n * @param {string[]} options.exclude Will be filtered from \"PATH\" env.\n * @return {string[]} Directories to dig into.\n */\nconst getDirsToWalkThrough = (options: LookPathOption): string[] => {\n    const envVars = options.env || process.env\n    const envName = process.platform === 'win32' ? 'Path' : 'PATH'\n    const envPath = envVars[envName] || ''\n    return envPath\n        .split(path.delimiter)\n        .concat(options.include || [])\n        .filter(p => !(options.exclude || []).includes(p))\n}\n\n/**\n * Returns async promise with absolute file path of given command,\n * and resolves with undefined if the command not found.\n * @param {string} command Command name to look for.\n * @param {LookPathOption} opt Options for lookPath.\n * @return {Promise<string|undefined>} Resolves absolute file path, or undefined if not found.\n */\nexport async function lookPath(command: string, opt: LookPathOption = {}): Promise<string | undefined> {\n    const directPath = isFilePath(command)\n    if (directPath) return isExecutable(directPath, opt)\n\n    const dirs = getDirsToWalkThrough(opt)\n    const bins = await Promise.all(dirs.map(async dir => isExecutable(path.join(dir, command), opt)))\n    return bins.find(bin => !!bin)\n}\n\n/**\n * Options for lookPath.\n */\nexport interface LookPathOption {\n    /**\n     * Additional paths to look for, would be dealt same as PATH env.\n     * Example: ['/tmp/bin', 'usr/local/bin']\n     */\n    include?: string[]\n    /**\n     * Paths to exclude to look for.\n     * Example: ['/mnt']\n     */\n    exclude?: string[]\n    /**\n     * Set of env var to be used ON BEHALF OF the existing env of your runtime.\n     * If `include` or `exclude` are given, they will be applied to this env set.\n     */\n    env?: NodeJS.ProcessEnv\n}\n","import { exec as execNonPromise, ExecOptions } from 'node:child_process'\nimport * as fs from 'node:fs/promises'\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport * as util from 'node:util'\nimport * as semver from 'semver'\nimport { lookPath } from './lookPath'\nimport { type ExecResult } from './models'\n\nexport interface IBuildAgent {\n    agentName: string\n    sourceDirVariable: string\n    tempDirVariable: string\n    cacheDirVariable: string\n\n    sourceDir: string\n    tempDir: string\n    cacheDir: string\n\n    addPath(inputPath: string): void\n\n    debug(message: string): void\n\n    info(message: string): void\n\n    warn(message: string): void\n\n    error(message: string): void\n\n    exec(exec: string, args: string[]): Promise<ExecResult>\n\n    cacheToolDirectory(sourceDir: string, tool: string, version: string): Promise<string>\n\n    directoryExists(dir: string): Promise<boolean>\n\n    removeDirectory(dir: string): Promise<void>\n\n    fileExists(file: string): Promise<boolean>\n\n    findLocalTool(toolName: string, versionSpec: string): Promise<string | null>\n\n    getInput(input: string, required?: boolean): string\n\n    getInput<T>(input: Extract<keyof T, string>, required?: boolean): string\n\n    getBooleanInput<T>(input: Extract<keyof T, string>, required?: boolean): boolean\n\n    getDelimitedInput<T>(input: Extract<keyof T, string>, delimiter: string, required?: boolean): string[]\n\n    getListInput<T>(input: Extract<keyof T, string>, required?: boolean): string[]\n\n    setSucceeded(message: string, done?: boolean): void\n\n    setFailed(message: string, done?: boolean): void\n\n    setOutput(name: string, value: string): void\n\n    getVariable(name: string): string | undefined\n\n    getVariableAsPath(name: string): string\n\n    getExpandedString(pattern: string): string\n\n    setVariable(name: string, value: string): void\n\n    updateBuildNumber: (version: string) => void\n\n    which(tool: string, check?: boolean): Promise<string>\n}\n\nexport abstract class BuildAgentBase implements IBuildAgent {\n    abstract agentName: string\n    abstract sourceDirVariable: string\n    abstract tempDirVariable: string\n    abstract cacheDirVariable: string\n\n    abstract debug(message: string): void\n\n    abstract info(message: string): void\n\n    abstract warn(message: string): void\n\n    abstract error(message: string): void\n\n    abstract setSucceeded(message: string, done?: boolean): void\n\n    abstract setFailed(message: string, done?: boolean): void\n\n    abstract setOutput(name: string, value: string): void\n\n    abstract setVariable(name: string, value: string): void\n\n    abstract updateBuildNumber: (version: string) => void\n\n    get sourceDir(): string {\n        return this.getVariableAsPath(this.sourceDirVariable)?.replace(/\\\\/g, '/')\n    }\n\n    get tempDir(): string {\n        return this.getVariableAsPath(this.tempDirVariable)\n    }\n\n    get cacheDir(): string {\n        return this.getVariableAsPath(this.cacheDirVariable)\n    }\n\n    addPath(inputPath: string): void {\n        const envName = process.platform === 'win32' ? 'Path' : 'PATH'\n        const newPath = inputPath + path.delimiter + process.env[envName]\n        this.debug(`new Path: ${newPath}`)\n        process.env[envName] = newPath\n        process.env.Path = newPath\n        this.info(`Updated PATH: ${process.env[envName]}`)\n    }\n\n    getInput<T>(input: Extract<keyof T, string>, required?: boolean): string {\n        const inputProp = input.replace(/ /g, '_').toUpperCase()\n        const val = this.getVariable(`INPUT_${inputProp}`)\n        if (required && !val) {\n            throw new Error(`Input required and not supplied: ${inputProp}`)\n        }\n        return val.trim()\n    }\n\n    getBooleanInput<T>(input: Extract<keyof T, string>, required?: boolean): boolean {\n        const inputValue = this.getInput(input, required)\n        return (inputValue || 'false').toLowerCase() === 'true'\n    }\n\n    getDelimitedInput<T>(input: Extract<keyof T, string>, delimiter: string, required?: boolean): string[] {\n        return this.getInput(input, required)\n            .split(delimiter)\n            .filter(x => {\n                if (x) {\n                    return x.trim()\n                }\n            })\n    }\n\n    getListInput<T>(input: Extract<keyof T, string>, required?: boolean): string[] {\n        return this.getDelimitedInput(input, '\\n', required)\n    }\n\n    getVariable(name: string): string {\n        const value = (process.env[name] || '').trim()\n        this.debug(`getVariable - ${name}: ${value}`)\n        return value.trim()\n    }\n\n    getVariableAsPath(name: string): string {\n        return path.resolve(path.normalize(this.getVariable(name)))\n    }\n\n    /**\n     * Replaces environment variable references in a string with their values.\n     * Supports both $VAR and ${VAR} formats.\n     * Ignores invalid patterns like ${} or non-existing variables (replaced with empty string).\n     *\n     * @param pattern - The input string containing env variable placeholders.\n     * @returns The string with env variables expanded.\n     */\n    getExpandedString(pattern: string): string {\n        const expanded = pattern.replace(/\\$([a-zA-Z_][a-zA-Z0-9_]*|{([a-zA-Z_][a-zA-Z0-9_]*)})/g, (_, whole: string, braced?: string) => {\n            const name = braced ?? whole\n            const value = process.env[name.toUpperCase()]\n            return value !== undefined ? value : ''\n        })\n        this.debug(`getExpandedString - ${pattern}: ${expanded}`)\n        return expanded\n    }\n\n    async directoryExists(dir: string): Promise<boolean> {\n        try {\n            await fs.access(dir)\n            return (await fs.stat(dir)).isDirectory()\n        } catch (_error) {\n            return false\n        }\n    }\n\n    async removeDirectory(dir: string): Promise<void> {\n        await fs.rm(dir, { recursive: true, force: true, maxRetries: 3, retryDelay: 1000 })\n    }\n\n    async fileExists(file: string): Promise<boolean> {\n        try {\n            await fs.access(file)\n            return (await fs.stat(file)).isFile()\n        } catch (_error) {\n            return false\n        }\n    }\n\n    async cacheToolDirectory(sourceDir: string, tool: string, version: string): Promise<string> {\n        if (!tool) {\n            throw new Error('tool is a required parameter')\n        }\n        if (!version) {\n            throw new Error('version is a required parameter')\n        }\n        if (!sourceDir) {\n            throw new Error('sourceDir is a required parameter')\n        }\n\n        const cacheRoot = this.cacheDir\n        if (!cacheRoot) {\n            this.debug('cache root not set')\n            return ''\n        }\n\n        version = semver.clean(version) || version\n        const destPath = path.join(cacheRoot, tool, version)\n        if (await this.directoryExists(destPath)) {\n            this.debug(`Destination directory ${destPath} already exists, removing`)\n            await this.removeDirectory(destPath)\n        }\n\n        this.debug(`Copying ${sourceDir} to ${destPath}`)\n        await fs.mkdir(destPath, { recursive: true })\n        await fs.cp(sourceDir, destPath, { recursive: true, force: true })\n\n        this.debug(`Caching ${tool}@${version} from ${sourceDir}`)\n        return destPath\n    }\n\n    async findLocalTool(toolName: string, versionSpec: string): Promise<string | null> {\n        if (!toolName) {\n            throw new Error('toolName is a required parameter')\n        }\n        if (!versionSpec) {\n            throw new Error('versionSpec is a required parameter')\n        }\n\n        const cacheRoot = this.cacheDir\n        if (!cacheRoot) {\n            this.debug('cache root not set')\n            return null\n        }\n\n        versionSpec = semver.clean(versionSpec) || versionSpec\n        this.info(`Looking for local tool ${toolName}@${versionSpec}`)\n        const toolPath = path.join(cacheRoot, toolName, versionSpec)\n        if (!(await this.directoryExists(toolPath))) {\n            this.info(`Directory ${toolPath} not found`)\n            return null\n        } else {\n            this.info(`Found tool ${toolName}@${versionSpec} at ${toolPath}`)\n        }\n\n        return toolPath\n    }\n\n    async exec(cmd: string, args: string[]): Promise<ExecResult> {\n        const exec = util.promisify(execNonPromise)\n\n        try {\n            const commandOptions: ExecOptions = { maxBuffer: 1024 * 1024 * 10 } // 10MB\n            const { stdout, stderr } = await exec(`${cmd} ${args.join(' ')}`, commandOptions)\n            return {\n                code: 0,\n                error: null,\n                stderr,\n                stdout\n            }\n        } catch (e) {\n            const error = e as Error & { code: number; stderr: string; stdout: string }\n            return {\n                code: error.code,\n                error,\n                stderr: error.stderr,\n                stdout: error.stdout\n            }\n        }\n    }\n\n    async which(tool: string, _check?: boolean): Promise<string> {\n        this.debug(`looking for tool '${tool}' in PATH`)\n        let toolPath = await lookPath(tool)\n        if (toolPath) {\n            toolPath = path.resolve(toolPath)\n            this.debug(`found tool '${tool}' in PATH: ${toolPath}`)\n            return toolPath\n        }\n        throw new Error(`Unable to locate executable file: ${tool}`)\n    }\n}\n"],"names":["semver.clean","exec","execNonPromise"],"mappings":"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"}