{"version":3,"file":"lib.mjs","sources":["../../src/tools/lib.ts"],"sourcesContent":["import { parseArgs } from 'node:util'\n\nimport { type ExecResult, type IBuildAgent } from '@agents/common'\nimport { type IRunner } from '@tools/common'\n\ntype CliArgs = {\n    agent: string\n    tool: string\n    command: string\n}\n\nexport async function getAgent(buildAgent: string | undefined): Promise<IBuildAgent> {\n    const agent = `./${buildAgent}/agent.mjs`\n    const module = (await import(agent)) as { BuildAgent: new () => IBuildAgent }\n    return new module.BuildAgent()\n}\n\nexport async function getToolRunner(buildAgent: string | undefined, tool: string | undefined): Promise<IRunner> {\n    const agent = await getAgent(buildAgent)\n    const toolRunner = `./libs/${tool}.mjs`\n    const module = (await import(toolRunner)) as { Runner: new (buildAgent: IBuildAgent) => IRunner }\n    return new module.Runner(agent)\n}\n\nexport function parseCliArgs(): CliArgs {\n    return parseArgs({\n        options: {\n            agent: { type: 'string', short: 'a' },\n            tool: { type: 'string', short: 't' },\n            command: { type: 'string', short: 'c' }\n        }\n    }).values as CliArgs\n}\n\nexport async function run(agent: string, tool: string, command: string): Promise<ExecResult> {\n    const runner = await getToolRunner(agent, tool)\n    return await runner.run(command)\n}\n\n/**\n * Returns all indexes of a specified single character within a given string.\n *\n * Iterates through the `searchString` and collects the zero-based indexes\n * where the character `indexOf` appears. Throws an error if `indexOf` is not a single character.\n *\n * @param searchString - The string to search within.\n * @param indexOf - The single character to find in the string.\n * @returns An array of indexes where the character appears in the string.\n * @throws {Error} If `indexOf` is not a single character.\n */\nexport function allIndexesOf(searchString: string, indexOf: string): number[] {\n    if (indexOf.length !== 1) {\n        throw new Error('indexOf must be a single character')\n    }\n\n    const resultArray: number[] = []\n\n    for (let i = 0; i < searchString.length; i++) {\n        if (searchString[i] === indexOf) {\n            resultArray.push(i)\n        }\n    }\n\n    return resultArray\n}\n"],"names":[],"mappings":";;AAWA,eAAsB,SAAS,UAAA,EAAsD;AACjF,EAAA,MAAM,KAAA,GAAQ,KAAK,UAAU,CAAA,UAAA,CAAA;AAC7B,EAAA,MAAM,MAAA,GAAU,MAAM,OAAO,KAAA,CAAA;AAC7B,EAAA,OAAO,IAAI,OAAO,UAAA,EAAW;AACjC;AAEA,eAAsB,aAAA,CAAc,YAAgC,IAAA,EAA4C;AAC5G,EAAA,MAAM,KAAA,GAAQ,MAAM,QAAA,CAAS,UAAU,CAAA;AACvC,EAAA,MAAM,UAAA,GAAa,UAAU,IAAI,CAAA,IAAA,CAAA;AACjC,EAAA,MAAM,MAAA,GAAU,MAAM,OAAO,UAAA,CAAA;AAC7B,EAAA,OAAO,IAAI,MAAA,CAAO,MAAA,CAAO,KAAK,CAAA;AAClC;AAEO,SAAS,YAAA,GAAwB;AACpC,EAAA,OAAO,SAAA,CAAU;AAAA,IACb,OAAA,EAAS;AAAA,MACL,KAAA,EAAO,EAAE,IAAA,EAAM,QAAA,EAAU,OAAO,GAAA,EAAI;AAAA,MACpC,IAAA,EAAM,EAAE,IAAA,EAAM,QAAA,EAAU,OAAO,GAAA,EAAI;AAAA,MACnC,OAAA,EAAS,EAAE,IAAA,EAAM,QAAA,EAAU,OAAO,GAAA;AAAI;AAC1C,GACH,CAAA,CAAE,MAAA;AACP;AAEA,eAAsB,GAAA,CAAI,KAAA,EAAe,IAAA,EAAc,OAAA,EAAsC;AACzF,EAAA,MAAM,MAAA,GAAS,MAAM,aAAA,CAAc,KAAA,EAAO,IAAI,CAAA;AAC9C,EAAA,OAAO,MAAM,MAAA,CAAO,GAAA,CAAI,OAAO,CAAA;AACnC;AAaO,SAAS,YAAA,CAAa,cAAsB,OAAA,EAA2B;AAC1E,EAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACtB,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACxD;AAEA,EAAA,MAAM,cAAwB,EAAC;AAE/B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,QAAQ,CAAA,EAAA,EAAK;AAC1C,IAAA,IAAI,YAAA,CAAa,CAAC,CAAA,KAAM,OAAA,EAAS;AAC7B,MAAA,WAAA,CAAY,KAAK,CAAC,CAAA;AAAA,IACtB;AAAA,EACJ;AAEA,EAAA,OAAO,WAAA;AACX;;;;"}